import { VulnerabilityModel } from "@/lib/database/models/vulnerability"
import { SecurityEventModel } from "@/lib/database/models/security-event"

export interface Vulnerability {
  id: string
  title: string
  description: string
  severity: "critical" | "high" | "medium" | "low"
  cvss: number
  cve?: string
  package?: string
  version?: string
  fixedVersion?: string
  publishedDate: Date
  discoveredDate: Date
  status: "open" | "investigating" | "fixed" | "ignored"
  category: "dependency" | "configuration" | "code" | "infrastructure"
  impact: string[]
  recommendation: string
  references: string[]
}

export interface SecurityEvent {
  id: string
  type: "login_attempt" | "failed_login" | "suspicious_activity" | "vulnerability_detected" | "policy_violation"
  severity: "critical" | "high" | "medium" | "low" | "info"
  timestamp: Date
  userId?: string
  ip: string
  userAgent: string
  details: Record<string, any>
  resolved: boolean
  resolvedAt?: Date
  resolvedBy?: string
}

export interface SecurityMetrics {
  totalVulnerabilities: number
  criticalVulnerabilities: number
  highVulnerabilities: number
  mediumVulnerabilities: number
  lowVulnerabilities: number
  recentEvents: number
  failedLogins: number
  suspiciousActivities: number
  lastScanDate: Date
  systemHealth: "excellent" | "good" | "warning" | "critical"
}

export interface NVDResponse {
  resultsPerPage: number
  startIndex: number
  totalResults: number
  format: string
  version: string
  timestamp: string
  vulnerabilities: Array<{
    cve: {
      id: string
      sourceIdentifier: string
      published: string
      lastModified: string
      vulnStatus: string
      descriptions: Array<{
        lang: string
        value: string
      }>
      metrics: {
        cvssMetricV31?: Array<{
          source: string
          type: string
          cvssData: {
            version: string
            vectorString: string
            attackVector: string
            attackComplexity: string
            privilegesRequired: string
            userInteraction: string
            scope: string
            confidentialityImpact: string
            integrityImpact: string
            availabilityImpact: string
            baseScore: number
            baseSeverity: string
          }
        }>
      }
      weaknesses: Array<{
        source: string
        type: string
        description: Array<{
          lang: string
          value: string
        }>
      }>
      configurations: Array<{
        nodes: Array<{
          operator: string
          negate: boolean
          cpeMatch: Array<{
            vulnerable: boolean
            criteria: string
            matchCriteriaId: string
          }>
        }>
      }>
      references: Array<{
        url: string
        source: string
        tags: string[]
      }>
    }
  }>
}

class VulnerabilityScanner {
  private isScanning = false
  private readonly NVD_API_BASE = "https://services.nvd.nist.gov/rest/json/cves/2.0"
  private readonly GITHUB_API_BASE = "https://api.github.com/advisories"

  async scanDependencies(): Promise<Vulnerability[]> {
    try {
      const vulnerabilities: Vulnerability[] = []

      // Simulate dependency scanning by checking common vulnerable packages
      const commonVulnerablePackages = [
        {
          name: "lodash",
          version: "4.17.20",
          cve: "CVE-2021-23337",
          severity: "high" as const,
          description: "Command injection vulnerability in lodash",
        },
        {
          name: "axios",
          version: "0.21.0",
          cve: "CVE-2021-3749",
          severity: "medium" as const,
          description: "Regular expression denial of service in axios",
        },
      ]

      for (const pkg of commonVulnerablePackages) {
        const vulnerability: Vulnerability = {
          id: `dep-${pkg.name}-${Date.now()}`,
          type: "dependency",
          severity: pkg.severity,
          title: `Vulnerable dependency: ${pkg.name}`,
          description: pkg.description,
          cve: pkg.cve,
          cvss: pkg.severity === "high" ? 7.5 : 5.0,
          package: pkg.name,
          version: pkg.version,
          fixedVersion: undefined,
          publishedDate: new Date(),
          discoveredDate: new Date(),
          status: "open",
          category: "dependency",
          impact: [pkg.severity],
          recommendation: `Update ${pkg.name} to latest version`,
          references: [],
        }

        vulnerabilities.push(vulnerability)
        await VulnerabilityModel.create(vulnerability)
      }

      return vulnerabilities
    } catch (error) {
      console.error("Dependency scan failed:", error)
      return []
    }
  }

  async scanConfiguration(): Promise<Vulnerability[]> {
    this.isScanning = true
    const scanId = await this.createScanRecord("configuration_scan")

    try {
      const vulnerabilities: Vulnerability[] = []

      // Check security headers
      const headerVulns = await this.checkSecurityHeaders()
      vulnerabilities.push(...headerVulns)

      // Check SSL/TLS configuration
      const sslVulns = await this.checkSSLConfiguration()
      vulnerabilities.push(...sslVulns)

      // Check environment variables
      const envVulns = await this.checkEnvironmentSecurity()
      vulnerabilities.push(...envVulns)

      // Store vulnerabilities
      for (const vuln of vulnerabilities) {
        await this.storeVulnerability(vuln)
      }

      // Update scan record
      await this.updateScanRecord(scanId, {
        status: "completed",
        vulnerabilities_found: vulnerabilities.length,
        critical_count: vulnerabilities.filter((v) => v.severity === "critical").length,
        high_count: vulnerabilities.filter((v) => v.severity === "high").length,
        medium_count: vulnerabilities.filter((v) => v.severity === "medium").length,
        low_count: vulnerabilities.filter((v) => v.severity === "low").length,
        scan_results: { vulnerabilities },
        completed_at: new Date(),
      })

      return vulnerabilities
    } catch (error) {
      await this.updateScanRecord(scanId, {
        status: "failed",
        completed_at: new Date(),
      })

      console.error("Configuration scan failed:", error)
      throw error
    } finally {
      this.isScanning = false
    }
  }

  private async checkSecurityHeaders(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    try {
      // Check localhost for security headers
      const response = await fetch("http://localhost:3000", { method: "HEAD" })

      const requiredHeaders = [
        "X-Frame-Options",
        "X-Content-Type-Options",
        "X-XSS-Protection",
        "Strict-Transport-Security",
        "Content-Security-Policy",
      ]

      for (const header of requiredHeaders) {
        if (!response.headers.get(header)) {
          vulnerabilities.push({
            id: `header-${header.toLowerCase()}`,
            title: `Missing ${header} Header`,
            description: `The ${header} security header is not configured`,
            severity: header === "Content-Security-Policy" ? "high" : "medium",
            cvss: header === "Content-Security-Policy" ? 6.5 : 4.0,
            publishedDate: new Date(),
            discoveredDate: new Date(),
            status: "open",
            category: "configuration",
            impact: ["security_bypass"],
            recommendation: `Configure ${header} header for enhanced security`,
            references: ["https://owasp.org/www-project-secure-headers/"],
          })
        }
      }
    } catch (error) {
      console.error("Security headers check failed:", error)
    }

    return vulnerabilities
  }

  private async checkSSLConfiguration(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // This would typically check SSL/TLS configuration
    // For now, we'll create a placeholder check

    return vulnerabilities
  }

  private async checkEnvironmentSecurity(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Check for exposed sensitive environment variables
    const sensitivePatterns = ["password", "secret", "key", "token", "api_key"]

    // This is a simplified check - in production, you'd scan actual env files
    for (const pattern of sensitivePatterns) {
      if (process.env[pattern.toUpperCase()]) {
        vulnerabilities.push({
          id: `env-${pattern}`,
          title: `Potentially Exposed ${pattern.toUpperCase()}`,
          description: `Environment variable ${pattern.toUpperCase()} may contain sensitive data`,
          severity: "medium",
          cvss: 5.0,
          publishedDate: new Date(),
          discoveredDate: new Date(),
          status: "open",
          category: "configuration",
          impact: ["data_exposure"],
          recommendation: `Ensure ${pattern.toUpperCase()} is properly secured and not logged`,
          references: ["https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure"],
        })
      }
    }

    return vulnerabilities
  }

  private async createScanRecord(scanType: string): Promise<string> {
    const scan = await SecurityEventModel.create({
      event_type: scanType,
      severity: "info",
      resource: "security",
      action: "start_scan",
      details: {
        scan_type: scanType,
      },
    })
    return scan.id
  }

  private async updateScanRecord(scanId: string, updateData: any): Promise<void> {
    await SecurityEventModel.update(scanId, updateData)
  }

  private async storeVulnerability(vuln: Vulnerability): Promise<void> {
    try {
      // Check if vulnerability already exists
      if (vuln.cve) {
        const existing = await VulnerabilityModel.findByCVE(vuln.cve)
        if (existing) return
      }

      await VulnerabilityModel.create({
        cve_id: vuln.cve,
        title: vuln.title,
        description: vuln.description,
        severity: vuln.severity,
        cvss_score: vuln.cvss,
        affected_component: vuln.package,
        fixed_version: vuln.fixedVersion,
        published_date: vuln.publishedDate,
      })
    } catch (error) {
      console.error("Failed to store vulnerability:", error)
    }
  }

  private mapNpmSeverity(npmSeverity: string): "critical" | "high" | "medium" | "low" {
    switch (npmSeverity.toLowerCase()) {
      case "critical":
        return "critical"
      case "high":
        return "high"
      case "moderate":
        return "medium"
      case "low":
        return "low"
      default:
        return "medium"
    }
  }

  private mapCVSSSeverity(cvssScore: number): "critical" | "high" | "medium" | "low" {
    if (cvssScore >= 9.0) return "critical"
    if (cvssScore >= 7.0) return "high"
    if (cvssScore >= 4.0) return "medium"
    return "low"
  }

  async getVulnerabilities(): Promise<Vulnerability[]> {
    const dbVulns = await VulnerabilityModel.getAll()
    return dbVulns.map(this.convertDbVulnToVuln)
  }

  async getVulnerabilityById(id: string): Promise<Vulnerability | null> {
    // Implementation would fetch from database
    return null
  }

  async updateVulnerabilityStatus(id: string, status: Vulnerability["status"]): Promise<boolean> {
    // Implementation would update database
    return false
  }

  async getSecurityEvents(): Promise<SecurityEvent[]> {
    const events = await SecurityEventModel.getRecentEvents(100)
    return events.map((event) => ({
      id: event.id,
      type: event.event_type as any,
      severity: event.severity as any,
      timestamp: new Date(event.timestamp),
      userId: event.user_id || undefined,
      ip: event.ip_address || "unknown",
      userAgent: event.user_agent || "unknown",
      details: event.details,
      resolved: false,
    }))
  }

  async addSecurityEvent(event: Omit<SecurityEvent, "id" | "timestamp">): Promise<SecurityEvent> {
    const dbEvent = await SecurityEventModel.create({
      event_type: event.type,
      severity: event.severity,
      user_id: event.userId,
      ip_address: event.ip,
      user_agent: event.userAgent,
      details: event.details,
    })

    return {
      id: dbEvent.id,
      type: event.type,
      severity: event.severity,
      timestamp: new Date(dbEvent.timestamp),
      userId: event.userId,
      ip: event.ip,
      userAgent: event.userAgent,
      details: event.details,
      resolved: event.resolved,
    }
  }

  async resolveSecurityEvent(id: string, resolvedBy: string): Promise<boolean> {
    // Implementation would update database
    return false
  }

  async getSecurityMetrics(): Promise<SecurityMetrics> {
    const vulnerabilities = await this.getVulnerabilities()
    const events = await this.getSecurityEvents()

    const recentEvents = events.filter((e) => e.timestamp > new Date(Date.now() - 24 * 60 * 60 * 1000)).length

    const failedLogins = events.filter(
      (e) => e.type === "failed_login" && e.timestamp > new Date(Date.now() - 24 * 60 * 60 * 1000),
    ).length

    const suspiciousActivities = events.filter(
      (e) => e.type === "suspicious_activity" && e.timestamp > new Date(Date.now() - 24 * 60 * 60 * 1000),
    ).length

    const criticalVulns = vulnerabilities.filter((v) => v.severity === "critical" && v.status === "open").length
    const highVulns = vulnerabilities.filter((v) => v.severity === "high" && v.status === "open").length

    let systemHealth: SecurityMetrics["systemHealth"] = "excellent"
    if (criticalVulns > 0) {
      systemHealth = "critical"
    } else if (highVulns > 3 || suspiciousActivities > 10) {
      systemHealth = "warning"
    } else if (highVulns > 0 || suspiciousActivities > 5) {
      systemHealth = "good"
    }

    return {
      totalVulnerabilities: vulnerabilities.filter((v) => v.status === "open").length,
      criticalVulnerabilities: criticalVulns,
      highVulnerabilities: highVulns,
      mediumVulnerabilities: vulnerabilities.filter((v) => v.severity === "medium" && v.status === "open").length,
      lowVulnerabilities: vulnerabilities.filter((v) => v.severity === "low" && v.status === "open").length,
      recentEvents,
      failedLogins,
      suspiciousActivities,
      lastScanDate: new Date(),
      systemHealth,
    }
  }

  isCurrentlyScanning(): boolean {
    return this.isScanning
  }

  async performFullScan(): Promise<{
    dependencies: Vulnerability[]
    configuration: Vulnerability[]
    summary: SecurityMetrics
  }> {
    const [dependencies, configuration] = await Promise.all([this.scanDependencies(), this.scanConfiguration()])

    return {
      dependencies,
      configuration,
      summary: await this.getSecurityMetrics(),
    }
  }

  private convertDbVulnToVuln(dbVuln: any): Vulnerability {
    return {
      id: dbVuln.id,
      title: dbVuln.title,
      description: dbVuln.description,
      severity: dbVuln.severity,
      cvss: dbVuln.cvss_score || 0,
      cve: dbVuln.cve_id || undefined,
      package: dbVuln.affected_component || undefined,
      fixedVersion: dbVuln.fixed_version || undefined,
      publishedDate: dbVuln.published_date || dbVuln.created_at,
      discoveredDate: dbVuln.created_at,
      status: "open",
      category: "dependency",
      impact: [dbVuln.severity],
      recommendation: `Address ${dbVuln.severity} severity vulnerability`,
      references: [],
    }
  }

  private async fetchCVEData(cveId: string): Promise<any> {
    try {
      const response = await fetch(`https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${cveId}`)
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      return await response.json()
    } catch (error) {
      console.error(`Failed to fetch CVE data for ${cveId}:`, error)
      return null
    }
  }
}

export const vulnerabilityScanner = new VulnerabilityScanner()

// Utility functions
export function getSeverityBadgeVariant(
  severity: Vulnerability["severity"],
): "destructive" | "secondary" | "outline" | "default" {
  switch (severity) {
    case "critical":
      return "destructive"
    case "high":
      return "destructive"
    case "medium":
      return "secondary"
    case "low":
      return "outline"
    default:
      return "default"
  }
}

export function formatCVSS(cvss: number): string {
  if (cvss >= 9.0) return `${cvss} (Critical)`
  if (cvss >= 7.0) return `${cvss} (High)`
  if (cvss >= 4.0) return `${cvss} (Medium)`
  return `${cvss} (Low)`
}
